from core.module import BaseModule
from core.option import Option
from typing import Dict, Any
import importlib
import sys
import threading
from core.shared_state import shared_state

class MultiHandler(BaseModule):
    """
    Genel Payload Handler Modülü (exploit/multi/handler).
    Farklı payload türleri için dinleyici başlatır.
    """
    Name = "Generic Payload Handler"
    Description = "Genel payload dinleyici (handler)."
    Author = "Mahmut P."
    Category = "exploit"

    def __init__(self):
        super().__init__()
        self.Options = {
            "PAYLOAD": Option("PAYLOAD", "python/shell_reverse_tcp", True, "Dinlenecek payload türü."),
            "LHOST": Option("LHOST", "0.0.0.0", True, "Dinlenecek yerel IP adresi."),
            "LPORT": Option("LPORT", 4444, True, "Dinlenecek yerel Port."),
            "RHOST": Option("RHOST", "127.0.0.1", False, "Bağlanılacak Hedef IP (Bind Shell için)."),
            "BACKGROUND": Option("BACKGROUND", "false", True, "Handler arka planda mı çalışsın?")
        }
        self.current_handler = None
        self._update_payload_choices()

    def _update_payload_choices(self):
        """PAYLOAD seçeneği için mevcut payloadları yükler."""
        from core.shared_state import shared_state
        if shared_state.module_manager:
            all_modules = shared_state.module_manager.get_all_modules().keys()
            # Sadece 'payloads/' ile başlayan modülleri al
            payload_choices = [m for m in all_modules if m.startswith("payloads/")]
            # Seçeneklere ekle (Prefix olan 'payloads/' kısmını atarak daha temiz görünmesini isterseniz: m.replace("payloads/", ""))
            # Ancak kullanıcı tam yol girmeli, o yüzden olduğu gibi bırakıyoruz.
            
            # Seçeneklerin "choices" özelliğini güncelle
            self.Options["PAYLOAD"].choices = sorted(payload_choices)

    def run(self, options: Dict[str, Any]):
        payload_name_raw = options.get("PAYLOAD")
        lhost = options.get("LHOST")
        lport = int(options.get("LPORT"))

        print(f"[*] Handler başlatılıyor: {payload_name_raw} -> {lhost}:{lport}")
        
        # Payload yolu bazen "payloads/..." şeklinde gelebilir, bazen "modules/payloads/..."
        # Bizim module manager'daki key yapımız genelde "payloads/..." şeklindedir.
        # Handler dosyasını bulmak için path manipülasyonu yapıyoruz.
        
        # Örn: payloads/python/mahpreter/reverse_tcp/generate -> modules.payloads.python.mahpreter.reverse_tcp.handler
        
        try:
            # 1. Path temizliği
            base_module_path = payload_name_raw
            
            # "generate" suffix'ini at (eğer varsa)
            if base_module_path.endswith("/generate"):
                 base_module_path = base_module_path.replace("/generate", "")
            
            # Olası dublike "payloads/" veya yanlış prefixleri temizle
            # Kullanıcı yanlışlıkla "payloads/payloads/..." yazmış olabilir.
            while "//" in base_module_path:
                base_module_path = base_module_path.replace("//", "/")
            
            if base_module_path.startswith("payloads/payloads/"):
                base_module_path = base_module_path.replace("payloads/payloads/", "payloads/")

            if base_module_path.startswith("modules/"):
                base_module_path = base_module_path.replace("modules/", "")
            
            # 2. Path'i nokta notasyonuna çevir ve "modules." prefix'i ekle
            module_import_path = "modules." + base_module_path.replace("/", ".") + ".handler"
            
            print(f"[*] Handler modülü yükleniyor: {module_import_path}")
            
            # 3. Dinamik import
            handler_module = importlib.import_module(module_import_path)
            
            # 4. Handler sınıfını al
            HandlerClass = getattr(handler_module, "Handler")
            
            # 5. Handler'ı başlat
            background = str(options.get("BACKGROUND", "false")).lower() in ['true', '1', 'yes', 'y']
            
            handler_instance = HandlerClass(options)
            self.current_handler = handler_instance
            
            # Handler'ı her zaman thread içinde başlatırız (böylece asıl soket loop'u bloke olmaz/kapanmaz)
            handler_thread = threading.Thread(target=handler_instance.start)
            handler_thread.daemon = True
            handler_thread.start()
            
            if background:
                print(f"[*] Handler arka planda başlatıldı. (PID: {handler_thread.ident})")
                return True
            else:
                print(f"[*] Handler ön planda başlatıldı. Bağlantı bekleniyor... (Çıkmak için CTRL+C)")
                try:
                    import time
                    # Bağlantı gelene kadar bekle (Thread alive olduğu sürece)
                    while handler_thread.is_alive() and not getattr(handler_instance, "client_sock", None):
                        time.sleep(0.5)
                        
                    # Eğer handler bağlandıysa ve interaktif bir session başlattıysa main thread'den interact olmalıyız
                    # Session Manager'dan ilgili session'ı bul
                    if getattr(handler_instance, "client_sock", None):
                        # Chimera handle_connection kendi başına bir şey yazmaması için kısa bekleme
                        time.sleep(1)
                        # Bu oturumun ID'sini bul
                        from core.shared_state import shared_state
                        session_id = None
                        if shared_state.session_manager:
                            sessions = shared_state.session_manager.get_all_sessions()
                            for sid, sdata in sessions.items():
                                if sdata.get("handler") == handler_instance:
                                    session_id = sid
                                    break
                        
                        if session_id and hasattr(handler_instance, "interact"):
                            handler_instance.interact(session_id)
                except KeyboardInterrupt:
                    print("\n[*] Dinleme iptal edildi.")
                    handler_instance.stop()
            
            return True

            
        except ImportError:
            print(f"[!] Bu payload için özel bir 'handler.py' bulunamadı: {module_import_path}")
            print("[*] Lütfen bu payload için henüz handler desteği olmadığını not edin.")
            return False
        except AttributeError:
             print(f"[!] '{module_import_path}' içinde 'Handler' sınıfı bulunamadı.")
             return False
        except Exception as e:
            print(f"[!] Handler başlatılamadı: {e}")
            return False
